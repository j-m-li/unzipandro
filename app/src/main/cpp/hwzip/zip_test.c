/* This file is part of hwzip from https://www.hanshq.net/zip.html
   It is put in the public domain; see the LICENSE file for details. */

#include "zip.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "crc32.h"
#include "deflate.h"
#include "hamlet.h"
#include "test_utils.h"

/* Created by:
   $ echo -n foo > foo
   $ echo -n nanananana > bar
   $ mkdir dir
   $ echo -n baz > dir/baz
   $ touch --date="2019-09-21 12:34:56" foo bar dir dir/baz
   $ zip test.zip --entry-comments --archive-comment -r foo bar dir
     adding: foo (stored 0%)
     adding: bar (deflated 40%)
     adding: dir/ (stored 0%)
     adding: dir/baz (stored 0%)
   Enter comment for foo:
   foo
   Enter comment for bar:
   bar
   Enter comment for dir/:
   dir
   Enter comment for dir/baz:
   dirbaz
   enter new zip file comment (end with .):
   testzip
   .
   $ xxd -i < test.zip
*/
static const uint8_t basic_zip[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
  0x35, 0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x66, 0x6f, 0x6f, 0x55, 0x54, 0x09,
  0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x5b, 0xca, 0x8b, 0x5d, 0x75, 0x78,
  0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00,
  0x00, 0x66, 0x6f, 0x6f, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x5c, 0x64, 0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x06, 0x00,
  0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x61,
  0x72, 0x55, 0x54, 0x09, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x5b, 0xca,
  0x8b, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00,
  0x04, 0xe8, 0x03, 0x00, 0x00, 0xcb, 0x4b, 0xcc, 0x83, 0x42, 0x00, 0x50,
  0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35,
  0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x04, 0x00, 0x1c, 0x00, 0x64, 0x69, 0x72, 0x2f, 0x55, 0x54, 0x09,
  0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x6e, 0xca, 0x8b, 0x5d, 0x75, 0x78,
  0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00,
  0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c,
  0x64, 0x35, 0x4f, 0x98, 0x04, 0x24, 0x78, 0x03, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x07, 0x00, 0x1c, 0x00, 0x64, 0x69, 0x72, 0x2f, 0x62,
  0x61, 0x7a, 0x55, 0x54, 0x09, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0xd0,
  0xfc, 0x85, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00,
  0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x62, 0x61, 0x7a, 0x50, 0x4b, 0x01,
  0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35,
  0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x03, 0x00, 0x18, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x55, 0x54,
  0x05, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01,
  0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x66, 0x6f,
  0x6f, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x14, 0x00, 0x00, 0x00, 0x08,
  0x00, 0x5c, 0x64, 0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x06, 0x00, 0x00,
  0x00, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x18, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x40, 0x00, 0x00, 0x00, 0x62,
  0x61, 0x72, 0x55, 0x54, 0x05, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x75,
  0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03,
  0x00, 0x00, 0x62, 0x61, 0x72, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35, 0x4f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x18,
  0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xed, 0x41, 0x83,
  0x00, 0x00, 0x00, 0x64, 0x69, 0x72, 0x2f, 0x55, 0x54, 0x05, 0x00, 0x03,
  0xd0, 0xfc, 0x85, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03,
  0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x64, 0x69, 0x72, 0x50, 0x4b,
  0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
  0x35, 0x4f, 0x98, 0x04, 0x24, 0x78, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
  0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0xa4, 0x81, 0xc1, 0x00, 0x00, 0x00, 0x64, 0x69, 0x72, 0x2f,
  0x62, 0x61, 0x7a, 0x55, 0x54, 0x05, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d,
  0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8,
  0x03, 0x00, 0x00, 0x64, 0x69, 0x72, 0x62, 0x61, 0x7a, 0x50, 0x4b, 0x05,
  0x06, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x38, 0x01, 0x00,
  0x00, 0x05, 0x01, 0x00, 0x00, 0x07, 0x00, 0x74, 0x65, 0x73, 0x74, 0x7a,
  0x69, 0x70
};

/* Created by:
   (After running the steps for basic_zip above)
   $ curl -O https://www.hanshq.net/files/pkz204g.exe
   $ unzip pkz204g.exe PKZIP.EXE
   $ dosbox -c "mount c ." -c "c:" -c "pkzip pk.zip -P foo bar dir/baz" -c exit
   $ xxd -i < PK.ZIP
*/
static const uint8_t pk_zip[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
  0x35, 0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x4f, 0x4f, 0x66, 0x6f, 0x6f,
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
  0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x42, 0x41, 0x52, 0x6e, 0x61, 0x6e,
  0x61, 0x6e, 0x61, 0x6e, 0x61, 0x6e, 0x61, 0x50, 0x4b, 0x03, 0x04, 0x0a,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35, 0x4f, 0x98, 0x04, 0x24,
  0x78, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
  0x00, 0x44, 0x49, 0x52, 0x2f, 0x42, 0x41, 0x5a, 0x62, 0x61, 0x7a, 0x50,
  0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c,
  0x64, 0x35, 0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x4f, 0x4f,
  0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x5c, 0x64, 0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x0a, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x42, 0x41,
  0x52, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x5c, 0x64, 0x35, 0x4f, 0x98, 0x04, 0x24, 0x78, 0x03, 0x00, 0x00,
  0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x44,
  0x49, 0x52, 0x2f, 0x42, 0x41, 0x5a, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x97, 0x00, 0x00, 0x00, 0x77, 0x00,
  0x00, 0x00, 0x00, 0x00
};

/* From https://en.wikipedia.org/wiki/Zip_(file_format)#Limits */
static const uint8_t empty_zip[] = {
  0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Created by:
   $ echo -n 1234567 > a
   $ curl -O https://www.hanshq.net/files/pkz204g.exe
   $ unzip pkz204g.exe PKZIP.EXE
   $ dosbox -c "mount c ." -c "c:" -c "pkzip a.zip a" -c exit
   $ xxd -i < A.ZIP | sed 's/0x07/0x4d/g'

   Why 0x4d? Because there is room for a 0x4c payload (if we allow it to
   overlap with the cfh and eocdr):
   "1234567" (7 bytes) + cfh (46 bytes) + filename (1 byte) + eocdr (22 bytes)
 */
static const uint8_t out_of_bounds_member_zip[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x70,
  0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x4d, 0x00, 0x00, 0x00, 0x4d, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x41, 0x31, 0x32, 0x33, 0x34, 0x35,
  0x36, 0x37, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x70, 0x70, 0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x4d, 0x00,
  0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x41, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
  0x00, 0x2f, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Created by:
   $ for x in foo bar baz ; do echo $x > $x && zip $x.zip $x ; done
   $ zip test.zip foo.zip bar.zip baz.zip
   $ xxd -i < test.zip
 */
static const uint8_t zip_in_zip[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b,
  0x8f, 0x4f, 0xfc, 0xe0, 0x94, 0x8d, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00,
  0x00, 0x00, 0x07, 0x00, 0x1c, 0x00, 0x66, 0x6f, 0x6f, 0x2e, 0x7a, 0x69,
  0x70, 0x55, 0x54, 0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x2c, 0xef,
  0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00,
  0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xa8, 0x65, 0x32, 0x7e, 0x04,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x66,
  0x6f, 0x6f, 0x55, 0x54, 0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x0b,
  0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00,
  0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x0a, 0x50, 0x4b,
  0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b,
  0x8f, 0x4f, 0xa8, 0x65, 0x32, 0x7e, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x55,
  0x54, 0x05, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00,
  0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50,
  0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x49,
  0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03,
  0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0x09,
  0x2e, 0x40, 0x1a, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x07,
  0x00, 0x1c, 0x00, 0x62, 0x61, 0x72, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54,
  0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x2c, 0xef, 0xf5, 0x5d, 0x75,
  0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03,
  0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xd2, 0x4b, 0x8f, 0x4f, 0xe9, 0xb3, 0xa2, 0x04, 0x04, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x61, 0x72, 0x55,
  0x54, 0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x0b, 0xef, 0xf5, 0x5d,
  0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8,
  0x03, 0x00, 0x00, 0x62, 0x61, 0x72, 0x0a, 0x50, 0x4b, 0x01, 0x02, 0x1e,
  0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xe9,
  0xb3, 0xa2, 0x04, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4,
  0x81, 0x00, 0x00, 0x00, 0x00, 0x62, 0x61, 0x72, 0x55, 0x54, 0x05, 0x00,
  0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8,
  0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x49, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0x38, 0xcd, 0x36, 0x40,
  0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x07, 0x00, 0x1c, 0x00,
  0x62, 0x61, 0x7a, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54, 0x09, 0x00, 0x03,
  0x2c, 0xef, 0xf5, 0x5d, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00,
  0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50,
  0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f,
  0x4f, 0xe1, 0x39, 0x7b, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
  0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x61, 0x7a, 0x55, 0x54, 0x09, 0x00,
  0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x0b, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b,
  0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00,
  0x62, 0x61, 0x7a, 0x0a, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xe1, 0x39, 0x7b, 0xcc,
  0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x18, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00,
  0x00, 0x00, 0x62, 0x61, 0x7a, 0x55, 0x54, 0x05, 0x00, 0x03, 0x2c, 0xef,
  0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00,
  0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x01, 0x00, 0x49, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xfc, 0xe0, 0x94, 0x8d, 0xa0,
  0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00,
  0x00, 0x66, 0x6f, 0x6f, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54, 0x05, 0x00,
  0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8,
  0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x01, 0x02,
  0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f,
  0x09, 0x2e, 0x40, 0x1a, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xa4, 0x81, 0xe1, 0x00, 0x00, 0x00, 0x62, 0x61, 0x72, 0x2e, 0x7a, 0x69,
  0x70, 0x55, 0x54, 0x05, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78,
  0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00,
  0x00, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0x38, 0xcd, 0x36, 0x40, 0xa0, 0x00, 0x00,
  0x00, 0xa0, 0x00, 0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0xc2, 0x01, 0x00, 0x00, 0x62,
  0x61, 0x7a, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54, 0x05, 0x00, 0x03, 0x2c,
  0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00,
  0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0xe7, 0x00, 0x00, 0x00, 0xa3, 0x02,
  0x00, 0x00, 0x00, 0x00
};

/* Created by:
   $ echo -n 1234567 > a
   $ curl -O https://www.hanshq.net/files/pkz204g.exe
   $ unzip pkz204g.exe PKZIP.EXE
   $ dosbox -c "mount c ." -c "c:" -c "pkzip a.zip a" -c exit
   $ xxd -i < A.ZIP

   Then hand modify the lowest byte in uncomp_size from 0x07 to 0x08.
   This makes the uncompressed size not match the compressed size as it should.
 */
static const uint8_t bad_stored_uncomp_size_zip[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x70,
  0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x41, 0x31, 0x32, 0x33, 0x34, 0x35,
  0x36, 0x37, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x70, 0x70, 0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x07, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x41, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
  0x00, 0x2f, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00
};

static time_t magic_time(void)
{
        struct tm tm = {0};

        /* 2019-09-21 12:34:56 */
        tm.tm_year = 2019 - 1900;
        tm.tm_mon = 9 - 1;
        tm.tm_mday = 21;
        tm.tm_hour = 12;
        tm.tm_min = 34;
        tm.tm_sec = 56;

        tm.tm_isdst = -1;

        return mktime(&tm);
}

static void check_extract2(const zipmemb_t *m, const char *expected, size_t n)
{
        uint8_t *uncomp;

        CHECK(m->uncomp_size == n);
        CHECK(m->crc32 == crc32((const uint8_t*)expected, n));

        uncomp = malloc(n);
        assert(uncomp);

        CHECK(zip_extract_member(m, uncomp));
        CHECK(memcmp(uncomp, expected, n) == 0);

        free(uncomp);
}

static void check_extract(const zipmemb_t *m, const char *expected)
{
        check_extract2(m, expected, strlen(expected));
}

void test_zip_basic(void)
{
        zip_t z;
        zipiter_t i;
        zipmemb_t m;

        CHECK(zip_read(&z, basic_zip, sizeof(basic_zip)));
        CHECK(z.num_members == 4);
        CHECK(z.comment_len == 7);
        CHECK(memcmp(z.comment, "testzip", 7) == 0);

        i = z.members_begin;
        m = zip_member(&z, i);
        CHECK(m.name_len == 3);
        CHECK(memcmp(m.name, "foo", 3) == 0);
        CHECK(m.mtime == magic_time());
        CHECK(m.comment_len == 3);
        CHECK(memcmp(m.comment, "foo", 3) == 0);
        CHECK(m.is_dir == false);
        check_extract(&m, "foo");

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == 3);
        CHECK(memcmp(m.name, "bar", 3) == 0);
        CHECK(m.mtime == magic_time());
        CHECK(m.comment_len == 3);
        CHECK(memcmp(m.comment, "bar", 3) == 0);
        CHECK(m.is_dir == false);
        check_extract(&m, "nanananana");

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == 4);
        CHECK(memcmp(m.name, "dir/", 4) == 0);
        CHECK(m.mtime == magic_time());
        CHECK(m.comment_len == 3);
        CHECK(memcmp(m.comment, "dir", 3) == 0);
        CHECK(m.is_dir == true);

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == 7);
        CHECK(memcmp(m.name, "dir/baz", 7) == 0);
        CHECK(m.mtime == magic_time());
        CHECK(m.comment_len == 6);
        CHECK(memcmp(m.comment, "dirbaz", 3) == 0);
        CHECK(m.is_dir == false);
        check_extract(&m, "baz");

        i = m.next;
        CHECK(i == z.members_end);
}

void test_zip_pk(void)
{
        zip_t z;
        zipiter_t i;
        zipmemb_t m;

        CHECK(zip_read(&z, pk_zip, sizeof(pk_zip)));
        CHECK(z.num_members == 3);
        CHECK(z.comment_len == 0);

        i = z.members_begin;
        m = zip_member(&z, i);
        CHECK(m.name_len == 3);
        CHECK(memcmp(m.name, "FOO", 3) == 0);
        CHECK(m.mtime == magic_time());
        CHECK(m.comment_len == 0);
        CHECK(m.is_dir == false);
        check_extract(&m, "foo");

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == 3);
        CHECK(memcmp(m.name, "BAR", 3) == 0);
        CHECK(m.mtime == magic_time());
        CHECK(m.comment_len == 0);
        CHECK(m.is_dir == false);
        check_extract(&m, "nanananana");

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == 7);
        CHECK(memcmp(m.name, "DIR/BAZ", 7) == 0);
        CHECK(m.mtime == magic_time());
        CHECK(m.comment_len == 0);
        CHECK(m.is_dir == false);
        check_extract(&m, "baz");

        i = m.next;
        CHECK(i == z.members_end);
}

void test_zip_out_of_bounds_member(void)
{
        zip_t z;

        CHECK(!zip_read(&z, out_of_bounds_member_zip,
                        sizeof(out_of_bounds_member_zip)));
}

void test_zip_empty(void)
{
        zip_t z;

        /* Not enough bytes. */
        CHECK(!zip_read(&z, empty_zip, sizeof(empty_zip) - 1));

        CHECK(zip_read(&z, empty_zip, sizeof(empty_zip)));
        CHECK(z.comment_len == 0);
        CHECK(z.num_members == 0);
        CHECK(z.members_begin == z.members_end);
}

static void write_basic_callback(const char *filename, method_t method,
                                 uint32_t size, uint32_t comp_size)
{
        static int n = 0;

        switch (n) {
        case 0:
                CHECK(memcmp(filename, "one", 3) == 0);
                CHECK(size == 3);
                CHECK(comp_size <= 3);
                CHECK(method == ZIP_STORE);
                break;
        case 1:
                CHECK(memcmp(filename, "two", 3) == 0);
                CHECK(size == 9);
                CHECK(comp_size <= 9);
                CHECK(method == ZIP_DEFLATE);
                break;
        default:
                CHECK(false);
        }

        n++;
}

void test_zip_write_basic(void)
{
        static const char *const names[] = { "one", "two" };
        static const uint8_t data1[] = "foo";
        static const uint8_t data2[] = "barbarbar";
        static const uint8_t *const data[] = { data1, data2 };
        static const uint32_t sizes[] = { 3, 9 };
        time_t mtimes[2];
        static const char comment[] = "comment";
        size_t max_size, size;
        uint8_t *out, *in;
        zip_t z;
        zipiter_t i;
        zipmemb_t m;

        mtimes[0] = mtimes[1] = magic_time();

        max_size = zip_max_size(2, names, sizes, comment);
        out = malloc(max_size);

        size = zip_write(out, 2, names, data, sizes, mtimes, comment,
                         ZIP_DEFLATE, write_basic_callback);

        in = malloc(size);
        memcpy(in, out, size);
        free(out);

        CHECK(zip_read(&z, in, size));
        CHECK(z.num_members == 2);
        CHECK(z.comment_len == strlen(comment));
        CHECK(memcmp(z.comment, comment, z.comment_len) == 0);

        i = z.members_begin;
        m = zip_member(&z, i);
        CHECK(m.name_len == strlen(names[0]));
        CHECK(memcmp(m.name, names[0], m.name_len) == 0);
        CHECK(m.mtime == mtimes[0]);
        check_extract(&m, (const char*)data[0]);

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == strlen(names[1]));
        CHECK(memcmp(m.name, names[1], m.name_len) == 0);
        CHECK(m.mtime == mtimes[1]);
        check_extract(&m, (const char*)data[1]);

        i = m.next;
        CHECK(i == z.members_end);

        free(in);
}

void test_zip_write_empty(void)
{
        size_t max_size, size;
        uint8_t *out;

        max_size = zip_max_size(0, NULL, NULL, NULL);
        out = malloc(max_size);

        size = zip_write(out, 0, NULL, NULL, NULL, NULL,
                         NULL, ZIP_DEFLATE, NULL);
        CHECK(size == sizeof(empty_zip));
        CHECK(memcmp(out, empty_zip, size) == 0);

        free(out);
}

void test_zip_max_comment(void)
{
        char comment[UINT16_MAX + 1];
        size_t max_size, size;
        uint8_t *out;
        zip_t z;

        memset(comment, 'a', UINT16_MAX);
        comment[UINT16_MAX] = '\0';

        max_size = zip_max_size(0, NULL, NULL, comment);
        out = malloc(max_size + 1000);
        memset(out, '\0', max_size + 1000);
        size = zip_write(out, 0, NULL, NULL, NULL, NULL,
                         comment, ZIP_DEFLATE, NULL);
        CHECK(size <= max_size);
        CHECK(size == sizeof(empty_zip) + UINT16_MAX);

        CHECK(zip_read(&z, out, size));
        CHECK(z.comment_len == UINT16_MAX);
        CHECK(memcmp(z.comment, comment, UINT16_MAX) == 0);
        CHECK(z.num_members == 0);
        CHECK(z.members_begin == z.members_end);

        /* The EOCDR + comment don't fit. */
        CHECK(!zip_read(&z, out, size - 1));

        /* The EOCDR + comment should probably be at the end of the file as
           per the spec, but neither Info-ZIP nor PKZIP are that picky.
           There are files in the wild with some extra bytes at the end,
           so we cannot be picky either. */
        CHECK(zip_read(&z, out, size + 123));

        free(out);
}

void test_zip_in_zip(void)
{
        zip_t z;
        zipiter_t i;
        zipmemb_t m;

        CHECK(zip_read(&z, zip_in_zip, sizeof(zip_in_zip)));
        CHECK(z.num_members == 3);

        i = z.members_begin;
        m = zip_member(&z, i);
        CHECK(m.name_len == 7);
        CHECK(memcmp(m.name, "foo.zip", 7) == 0);

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == 7);
        CHECK(memcmp(m.name, "bar.zip", 7) == 0);

        i = m.next;
        m = zip_member(&z, i);
        CHECK(m.name_len == 7);
        CHECK(memcmp(m.name, "baz.zip", 7) == 0);

        CHECK(m.next == z.members_end);
}

void test_zip_bad_stored_uncomp_size(void)
{
        zip_t z;

        CHECK(!zip_read(&z, bad_stored_uncomp_size_zip,
                        sizeof(bad_stored_uncomp_size_zip)));
}


/* multizip - a zip file containing all the compression methods:

for x in 092 110 250 ; do
  dosbox -c "mount c ." -c "c:" -c "$(ls pk*$x*.exe) pkzip.exe" -c "exit"
  mv PKZIP.EXE $x.exe
done

# Store
echo -n foo > 0.txt
dosbox -c "mount c ." -c "c:" -c "110 x.zip 0.txt" -c exit

# Shrink
echo -n ababcbababaaaaaaa > 1.txt
dosbox -c "mount c ." -c "c:" -c "110 -es x.zip 1.txt" -c exit

# Reduce
for n in $(seq 2 5) ; do
  rm -f $n.txt
  for x in $(seq 1 42) ; do dd if=hamlet.txt bs=1 count=50 >> $n.txt ; done
done
dosbox -c "mount c ." -c "c:" -c "092 -ea1 x.zip 2.txt" -c "exit"
dosbox -c "mount c ." -c "c:" -c "092 -ea2 x.zip 3.txt" -c "exit"
dosbox -c "mount c ." -c "c:" -c "092 -ea3 x.zip 4.txt" -c "exit"
dosbox -c "mount c ." -c "c:" -c "092 -ea4 x.zip 5.txt" -c "exit"

# Implode
# 4KB wnd, no lit tree; zipinfo "i4:2"
dd if=/dev/zero of=61.txt bs=1 count=256
dosbox -c "mount c ." -c "c:" -c "110 -ei x.zip 61.txt" -c exit
# 8KB wnd, lit tree; zipinfo "i8:3"
rm -f 62.txt
for x in $(seq 1 200) ; do dd if=hamlet.txt bs=1 count=50 >> 62.txt ; done
dosbox -c "mount c ." -c "c:" -c "110 -ei x.zip 62.txt" -c exit

# Deflate
dd if=hamlet.txt of=8.txt bs=1 count=128
dosbox -c "mount c ." -c "c:" -c "250 -exx x.zip 8.txt" -c exit
*/
static const uint8_t multizip[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x4a,
  0x3b, 0x51, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x30, 0x2e, 0x54, 0x58, 0x54, 0x66,
  0x6f, 0x6f, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x62, 0x4a, 0x3b, 0x51, 0x02, 0x04, 0x12, 0x39, 0x0c, 0x00, 0x00, 0x00,
  0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x31, 0x2e, 0x54, 0x58,
  0x54, 0x61, 0xc4, 0x04, 0x1c, 0x23, 0xb0, 0x60, 0x98, 0x83, 0x08, 0xc3,
  0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x63,
  0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x0a, 0x01, 0x00, 0x00, 0x34,
  0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x32, 0x2e, 0x54, 0x58, 0x54,
  0xc2, 0xff, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x08, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x20, 0xb4, 0x8d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xbb, 0xbf, 0x0d, 0x0a,
  0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x47, 0x75, 0x74, 0x65,
  0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42, 0x6f, 0x6f, 0x6b, 0x20,
  0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1, 0xb1, 0x80, 0x88, 0xe5,
  0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01, 0xf9, 0x25, 0x06, 0x72,
  0x98, 0x90, 0x1a, 0x1d, 0x43, 0xc2, 0x47, 0x48, 0x10, 0x10, 0x10, 0x7a,
  0xcc, 0x03, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x00,
  0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x0f, 0x01, 0x00, 0x00,
  0x34, 0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x33, 0x2e, 0x54, 0x58,
  0x54, 0xc2, 0xff, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x08, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x10, 0xb4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xbb, 0xbf, 0x0d, 0x0a,
  0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x47, 0x75, 0x74, 0x65,
  0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42, 0x6f, 0x6f, 0x6b, 0x20,
  0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1, 0xb1, 0x80, 0x88, 0xe5,
  0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01, 0xf9, 0x25, 0x06, 0x52,
  0x91, 0x31, 0x48, 0x0d, 0x8f, 0x21, 0xff, 0xfd, 0x7f, 0x84, 0xfc, 0xfb,
  0x7f, 0x17, 0x12, 0x04, 0x04, 0x84, 0x1d, 0xe7, 0x50, 0x4b, 0x03, 0x04,
  0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e,
  0x6d, 0x9c, 0x16, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05, 0x00,
  0x00, 0x00, 0x34, 0x2e, 0x54, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1f, 0xff, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xb4, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xbb,
  0xbf, 0x0d, 0x0a, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x47,
  0x75, 0x74, 0x65, 0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42, 0x6f,
  0x6f, 0x6b, 0x20, 0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1, 0xb1,
  0x80, 0x88, 0xe5, 0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01, 0x09,
  0x44, 0x0c, 0x24, 0x42, 0x63, 0x90, 0x98, 0x1e, 0x43, 0xfe, 0xf9, 0x7f,
  0x84, 0xfc, 0xf5, 0x9f, 0x08, 0xf9, 0xef, 0xbf, 0x16, 0xf2, 0xe7, 0x7f,
  0x38, 0xe4, 0xef, 0xff, 0x06, 0x48, 0xbb, 0x0f, 0x00, 0x50, 0x4b, 0x03,
  0x04, 0x0a, 0x00, 0x00, 0x00, 0x05, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e,
  0x4e, 0x6d, 0x9c, 0x1a, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05,
  0x00, 0x00, 0x00, 0x35, 0x2e, 0x54, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x7f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xb4, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef,
  0xbb, 0xbf, 0x0d, 0x0a, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20,
  0x47, 0x75, 0x74, 0x65, 0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42,
  0x6f, 0x6f, 0x6b, 0x20, 0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1,
  0xb1, 0x80, 0x88, 0xe5, 0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01,
  0x09, 0x48, 0x0c, 0x24, 0x52, 0x63, 0x90, 0xd8, 0x1e, 0x43, 0xfe, 0xf8,
  0x7f, 0x84, 0xfc, 0xf2, 0x9f, 0x08, 0xf9, 0xe7, 0x7f, 0x10, 0xf2, 0xd3,
  0xff, 0x2b, 0xe4, 0xaf, 0xff, 0x54, 0xc8, 0x6f, 0xff, 0xd5, 0x90, 0xb2,
  0x3c, 0x03, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00,
  0x65, 0x4a, 0x3b, 0x51, 0x58, 0x85, 0x96, 0x0d, 0x1d, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x36, 0x31, 0x2e, 0x54,
  0x58, 0x54, 0x0f, 0x00, 0x12, 0x03, 0x24, 0x15, 0x36, 0x27, 0x38, 0x39,
  0x6a, 0x7b, 0x4c, 0x9d, 0x6e, 0x1f, 0x09, 0x06, 0x01, 0x13, 0x34, 0xe5,
  0xf6, 0x96, 0xf7, 0xfe, 0x04, 0xf8, 0x6f, 0x50, 0x4b, 0x03, 0x04, 0x0a,
  0x00, 0x06, 0x00, 0x06, 0x00, 0x65, 0x4a, 0x3b, 0x51, 0xf1, 0x0d, 0xc3,
  0x06, 0x19, 0x01, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x06, 0x00, 0x00,
  0x00, 0x36, 0x32, 0x2e, 0x54, 0x58, 0x54, 0x61, 0x0a, 0x7b, 0x07, 0x06,
  0x1b, 0x06, 0xbb, 0x0c, 0x4b, 0x03, 0x09, 0x07, 0x0b, 0x09, 0x0b, 0x09,
  0x07, 0x16, 0x07, 0x08, 0x06, 0x05, 0x06, 0x07, 0x06, 0x05, 0x36, 0x07,
  0x16, 0x17, 0x0b, 0x0a, 0x06, 0x08, 0x0a, 0x0b, 0x05, 0x06, 0x15, 0x04,
  0x06, 0x17, 0x05, 0x0a, 0x08, 0x05, 0x06, 0x15, 0x06, 0x0a, 0x25, 0x06,
  0x08, 0x07, 0x18, 0x0a, 0x07, 0x0a, 0x08, 0x0b, 0x07, 0x0b, 0x04, 0x25,
  0x04, 0x25, 0x04, 0x0a, 0x06, 0x04, 0x05, 0x14, 0x05, 0x09, 0x34, 0x07,
  0x06, 0x17, 0x09, 0x1a, 0x2b, 0xfc, 0xfc, 0xfc, 0xfb, 0xfb, 0xfb, 0x0c,
  0x0b, 0x2c, 0x0b, 0x2c, 0x0b, 0x3c, 0x0b, 0x2c, 0x2b, 0xac, 0x0c, 0x01,
  0x22, 0x23, 0x14, 0x15, 0x36, 0x37, 0x68, 0x89, 0x9a, 0xdb, 0x3c, 0x05,
  0x06, 0x12, 0x23, 0x14, 0xe5, 0xf6, 0x96, 0xf7, 0x01, 0x6c, 0x50, 0x08,
  0x32, 0x45, 0xc5, 0x49, 0xdb, 0x1e, 0x42, 0x77, 0x63, 0xf9, 0x51, 0xe7,
  0xe5, 0x3e, 0x9a, 0xf7, 0x56, 0xfd, 0x6f, 0xea, 0xbe, 0x27, 0xfc, 0xbd,
  0xf6, 0xa3, 0x3c, 0xe5, 0xf3, 0x5e, 0xf2, 0x7f, 0x33, 0xdc, 0x8f, 0x7c,
  0x9d, 0xe7, 0xf5, 0x94, 0xc5, 0x8e, 0xfa, 0xeb, 0x36, 0xea, 0x2f, 0x11,
  0x51, 0x7f, 0x67, 0x1f, 0xf5, 0x37, 0x71, 0x50, 0x7f, 0x71, 0x0b, 0xf5,
  0xd7, 0xd1, 0x51, 0x7f, 0x49, 0x15, 0xf5, 0x77, 0x92, 0x50, 0x7f, 0x53,
  0x21, 0xea, 0x2f, 0xc6, 0x43, 0xfd, 0x75, 0x39, 0xa8, 0xbf, 0x04, 0x13,
  0xf5, 0x77, 0xa6, 0xa3, 0xfe, 0x26, 0x14, 0xd4, 0x5f, 0x9c, 0x84, 0xfa,
  0xeb, 0xe0, 0x51, 0x7f, 0x49, 0x2c, 0xea, 0xef, 0x84, 0x42, 0xfd, 0x4d,
  0x11, 0xa8, 0xbf, 0x18, 0x2c, 0xea, 0xaf, 0x0b, 0x8d, 0xfa, 0x4b, 0x40,
  0xa0, 0xfe, 0xce, 0x60, 0xa8, 0xbf, 0x09, 0x30, 0xea, 0x2f, 0x0e, 0x88,
  0xfa, 0xab, 0x02, 0xa0, 0xfe, 0xaa, 0x00, 0xa8, 0xbf, 0x2a, 0x00, 0xea,
  0xaf, 0x0a, 0x80, 0xfa, 0xab, 0x02, 0xa0, 0xfe, 0xaa, 0x00, 0x20, 0x04,
  0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x66, 0x4a,
  0x3b, 0x51, 0x9f, 0xf7, 0x53, 0x5a, 0x76, 0x00, 0x00, 0x00, 0x80, 0x00,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x38, 0x2e, 0x54, 0x58, 0x54, 0x7b,
  0xbf, 0x7b, 0x3f, 0x2f, 0x57, 0x40, 0x51, 0x7e, 0x56, 0x6a, 0x72, 0x89,
  0x82, 0x7b, 0x69, 0x49, 0x6a, 0x5e, 0x52, 0x6a, 0x51, 0xba, 0x82, 0xab,
  0x53, 0x7e, 0x7e, 0xb6, 0x42, 0x7e, 0x9a, 0x82, 0x47, 0x62, 0x6e, 0x4e,
  0x6a, 0x89, 0x8e, 0x42, 0x52, 0xa5, 0x42, 0x78, 0x66, 0x4e, 0x4e, 0x66,
  0x62, 0xae, 0x42, 0x70, 0x46, 0x62, 0x76, 0x6a, 0x71, 0x41, 0x6a, 0x62,
  0x51, 0x2a, 0x2f, 0x17, 0x2f, 0x57, 0x48, 0x46, 0x66, 0xb1, 0x42, 0x2a,
  0x58, 0x3d, 0x90, 0x91, 0x96, 0x5f, 0xa4, 0x50, 0x92, 0x91, 0xaa, 0x50,
  0x5a, 0x9c, 0x0a, 0xd2, 0x9e, 0x98, 0x57, 0x99, 0x9f, 0x97, 0x0a, 0xa2,
  0xca, 0x33, 0x52, 0x8b, 0x52, 0x15, 0x32, 0xf3, 0xc0, 0xb2, 0xa1, 0x79,
  0x99, 0x25, 0xa9, 0x29, 0x0a, 0xc1, 0x25, 0x89, 0x00, 0x50, 0x4b, 0x01,
  0x02, 0x0b, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x4a, 0x3b,
  0x51, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x2e, 0x54, 0x58, 0x54,
  0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x62, 0x4a, 0x3b, 0x51, 0x02, 0x04, 0x12, 0x39, 0x0c, 0x00, 0x00, 0x00,
  0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x31, 0x2e,
  0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x0a,
  0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00,
  0x00, 0x32, 0x2e, 0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0a, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e,
  0x6d, 0x9c, 0x0f, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x82, 0x01, 0x00, 0x00, 0x33, 0x2e, 0x54, 0x58, 0x54, 0x50, 0x4b, 0x01,
  0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x63, 0x4a, 0x3b,
  0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x16, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00,
  0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20,
  0x00, 0x00, 0x00, 0xb4, 0x02, 0x00, 0x00, 0x34, 0x2e, 0x54, 0x58, 0x54,
  0x50, 0x4b, 0x01, 0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x05, 0x00,
  0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x1a, 0x01, 0x00, 0x00,
  0x34, 0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0xed, 0x03, 0x00, 0x00, 0x35, 0x2e,
  0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0a, 0x00, 0x00,
  0x00, 0x06, 0x00, 0x65, 0x4a, 0x3b, 0x51, 0x58, 0x85, 0x96, 0x0d, 0x1d,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2a, 0x05, 0x00,
  0x00, 0x36, 0x31, 0x2e, 0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0b,
  0x00, 0x0a, 0x00, 0x06, 0x00, 0x06, 0x00, 0x65, 0x4a, 0x3b, 0x51, 0xf1,
  0x0d, 0xc3, 0x06, 0x19, 0x01, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x06,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00,
  0x00, 0x6b, 0x05, 0x00, 0x00, 0x36, 0x32, 0x2e, 0x54, 0x58, 0x54, 0x50,
  0x4b, 0x01, 0x02, 0x19, 0x00, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x66,
  0x4a, 0x3b, 0x51, 0x9f, 0xf7, 0x53, 0x5a, 0x76, 0x00, 0x00, 0x00, 0x80,
  0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x20, 0x00, 0x00, 0x00, 0xa8, 0x06, 0x00, 0x00, 0x38, 0x2e, 0x54,
  0x58, 0x54, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00,
  0x09, 0x00, 0xcd, 0x01, 0x00, 0x00, 0x41, 0x07, 0x00, 0x00, 0x00, 0x00
};

void test_zip_many_methods(void)
{
        /* Test reading a zip file with many different compression methods. */
        zip_t z;
        zipiter_t it;
        zipmemb_t m;
        uint8_t *uncomp;
        size_t i;

        uncomp = malloc(100000);
        assert(uncomp);
        CHECK(zip_read(&z, multizip, sizeof(multizip)));
        CHECK(z.num_members == 9);

        it = z.members_begin;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "0.TXT", 5) == 0);
        CHECK(m.method == ZIP_STORE);
        CHECK(zip_extract_member(&m, uncomp));
        CHECK(memcmp(uncomp, "foo", 3) == 0);

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "1.TXT", 5) == 0);
        CHECK(m.method == ZIP_SHRINK);
        CHECK(zip_extract_member(&m, uncomp));
        CHECK(memcmp(uncomp, "ababcbababaaaaaaa", 17) == 0);

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "2.TXT", 5) == 0);
        CHECK(m.method == ZIP_REDUCE1);
        CHECK(zip_extract_member(&m, uncomp));
        for (i = 0; i < 42 * 50; i++) {
                CHECK(uncomp[i] == hamlet[i % 50]);
        }

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "3.TXT", 5) == 0);
        CHECK(m.method == ZIP_REDUCE2);
        CHECK(zip_extract_member(&m, uncomp));
        for (i = 0; i < 42 * 50; i++) {
                CHECK(uncomp[i] == hamlet[i % 50]);
        }

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "4.TXT", 5) == 0);
        CHECK(m.method == ZIP_REDUCE3);
        CHECK(zip_extract_member(&m, uncomp));
        for (i = 0; i < 42 * 50; i++) {
                CHECK(uncomp[i] == hamlet[i % 50]);
        }

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "5.TXT", 5) == 0);
        CHECK(m.method == ZIP_REDUCE4);
        CHECK(zip_extract_member(&m, uncomp));
        for (i = 0; i < 42 * 50; i++) {
                CHECK(uncomp[i] == hamlet[i % 50]);
        }

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "61.TXT", 6) == 0);
        CHECK(m.method == ZIP_IMPLODE);
        CHECK(m.imp_large_wnd == false);
        CHECK(m.imp_lit_tree == false);
        CHECK(zip_extract_member(&m, uncomp));
        for (i = 0; i < 128; i++) {
                CHECK(uncomp[i] == 0);
        }

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "62.TXT", 6) == 0);
        CHECK(m.method == ZIP_IMPLODE);
        CHECK(m.imp_large_wnd == true);
        CHECK(m.imp_lit_tree == true);
        CHECK(zip_extract_member(&m, uncomp));
        for (i = 0; i < 200 * 50; i++) {
                CHECK(uncomp[i] == hamlet[i % 50]);
        }

        it = m.next;
        m = zip_member(&z, it);
        CHECK(memcmp(m.name, "8.TXT", 5) == 0);
        CHECK(m.method == ZIP_DEFLATE);
        CHECK(zip_extract_member(&m, uncomp));
        for (i = 0; i < 128; i++) {
                CHECK(uncomp[i] == hamlet[i]);
        }

        it = m.next;
        CHECK(it == z.members_end);
        free(uncomp);
}

/*
Created by a hacked up version of hwzip.
It uses all combinations of the large_wnd and lit_tree flags,
in 1.01/1.02 and 1.10 compatible modes.

In particular, pkzip 1.01/1.02 will not be able to decompress b & c,
and pkzip 1.1, info-zip etc. won't be able to decompress f & g.

hwzip is aware of the problem and can to handle it.

-rw-a--     1.1 fat       19 b- i4:2 20-Sep-29 22:06 a
-rw-a--     1.1 fat       19 b- i4:3 20-Sep-29 22:06 b
-rw-a--     1.1 fat       19 b- i8:2 20-Sep-29 22:06 c
-rw-a--     1.1 fat       19 b- i8:3 20-Sep-29 22:06 d
-rw-a--     1.0 fat       19 b- i4:2 20-Sep-29 22:06 e
-rw-a--     1.0 fat       19 b- i4:3 20-Sep-29 22:06 f
-rw-a--     1.0 fat       19 b- i8:2 20-Sep-29 22:06 g
-rw-a--     1.0 fat       19 b- i8:3 20-Sep-29 22:06 h
*/
static const uint8_t legacy_implode_zip[] = {
  0x50, 0x4b, 0x03, 0x04, 0x0b, 0x00, 0x00, 0x00, 0x06, 0x00, 0xdb, 0xb0,
  0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x07, 0x16, 0x02, 0x16, 0xf5,
  0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05,
  0xc3, 0x86, 0x0d, 0x1b, 0x36, 0xa6, 0x58, 0xb1, 0x62, 0xc5, 0xca, 0x48,
  0xfe, 0x33, 0x92, 0x1f, 0x50, 0x4b, 0x03, 0x04, 0x0b, 0x00, 0x04, 0x00,
  0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00,
  0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x16,
  0x38, 0xf7, 0xf7, 0x77, 0x48, 0x25, 0xf8, 0xf8, 0xc8, 0x13, 0xd8, 0xf7,
  0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0x78, 0x37, 0x18, 0x07, 0x07,
  0x06, 0x02, 0x26, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5,
  0xf5, 0xf5, 0x96, 0x05, 0xff, 0xff, 0x7f, 0x7f, 0xef, 0xbd, 0x9b, 0xe4,
  0xbf, 0x4a, 0x7e, 0x50, 0x4b, 0x03, 0x04, 0x0b, 0x00, 0x02, 0x00, 0x06,
  0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00,
  0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x63, 0x07, 0x16,
  0x02, 0x16, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5,
  0xf5, 0x96, 0x05, 0xc3, 0x86, 0x0d, 0x1b, 0x36, 0xa6, 0x58, 0xb1, 0x62,
  0xc5, 0xca, 0x48, 0xfc, 0x67, 0x24, 0x7e, 0x50, 0x4b, 0x03, 0x04, 0x0b,
  0x00, 0x06, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8,
  0xaa, 0x35, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x64, 0x16, 0x38, 0xf7, 0xf7, 0x77, 0x48, 0x25, 0xf8, 0xf8, 0xc8,
  0x13, 0xd8, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0x78, 0x37,
  0x18, 0x07, 0x07, 0x06, 0x02, 0x26, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06,
  0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xff, 0xff, 0x7f, 0x7f, 0xef,
  0xbd, 0x9b, 0xc4, 0x7f, 0x95, 0xf8, 0x01, 0x50, 0x4b, 0x03, 0x04, 0x0a,
  0x00, 0x00, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8,
  0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x65, 0x07, 0x16, 0x02, 0x16, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06,
  0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xc3, 0x86, 0x0d, 0x1b, 0x36,
  0xa6, 0x58, 0xb1, 0x62, 0xc5, 0xca, 0x48, 0xfe, 0x33, 0x92, 0x1f, 0x50,
  0x4b, 0x03, 0x04, 0x0a, 0x00, 0x04, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d,
  0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x66, 0x16, 0x38, 0xf7, 0xf7, 0x77, 0x48,
  0x25, 0xf8, 0xf8, 0xc8, 0x13, 0xd8, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7,
  0xf7, 0xf7, 0x78, 0x37, 0x18, 0x07, 0x07, 0x16, 0x02, 0x16, 0xf5, 0xf5,
  0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xff,
  0xff, 0x7f, 0x7f, 0xef, 0xbd, 0x9b, 0xe4, 0xbf, 0x4a, 0x7e, 0x50, 0x4b,
  0x03, 0x04, 0x0a, 0x00, 0x02, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51,
  0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x67, 0x07, 0x06, 0x02, 0x26, 0xf5, 0xf5, 0xf5,
  0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xc3, 0x86,
  0x0d, 0x1b, 0x36, 0xa6, 0x58, 0xb1, 0x62, 0xc5, 0xca, 0x48, 0xfc, 0x67,
  0x24, 0x7e, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x06, 0x00, 0x06, 0x00,
  0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x35, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x16, 0x38, 0xf7,
  0xf7, 0x77, 0x48, 0x25, 0xf8, 0xf8, 0xc8, 0x13, 0xd8, 0xf7, 0xf7, 0xf7,
  0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0x78, 0x37, 0x18, 0x07, 0x07, 0x06, 0x02,
  0x26, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5,
  0x96, 0x05, 0xff, 0xff, 0x7f, 0x7f, 0xef, 0xbd, 0x9b, 0xc4, 0x7f, 0x95,
  0xf8, 0x01, 0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00,
  0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x61, 0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x04, 0x00, 0x06,
  0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00, 0x00,
  0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x62,
  0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x02, 0x00, 0x06, 0x00,
  0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x63, 0x50,
  0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x06, 0x00, 0xdb,
  0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x35, 0x00, 0x00, 0x00, 0x13,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x00, 0xd3, 0x00, 0x00, 0x00, 0x64, 0x50, 0x4b,
  0x01, 0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00, 0xdb, 0xb0,
  0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x27, 0x01, 0x00, 0x00, 0x65, 0x50, 0x4b, 0x01,
  0x02, 0x0a, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d,
  0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x00, 0x67, 0x01, 0x00, 0x00, 0x66, 0x50, 0x4b, 0x01, 0x02,
  0x0a, 0x00, 0x0a, 0x00, 0x02, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51,
  0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x00, 0xba, 0x01, 0x00, 0x00, 0x67, 0x50, 0x4b, 0x01, 0x02, 0x0a,
  0x00, 0x0a, 0x00, 0x06, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f,
  0xb9, 0xb8, 0xaa, 0x35, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x00, 0xfa, 0x01, 0x00, 0x00, 0x68, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x78, 0x01, 0x00, 0x00, 0x4e, 0x02,
  0x00, 0x00, 0x00, 0x00
};
void test_zip_legacy_implode(void)
{
        zip_t z;
        zipiter_t it;
        zipmemb_t m;
        uint8_t *uncomp;
        size_t i;

        uncomp = malloc(100);
        assert(uncomp);
        CHECK(zip_read(&z, legacy_implode_zip, sizeof(legacy_implode_zip)));
        CHECK(z.num_members == 8);

        it = z.members_begin;

        for (i = 0; i < 8; i++) {
                m = zip_member(&z, it);
                CHECK(m.name[0] == "abcdefgh"[i]);
                CHECK(m.method == ZIP_IMPLODE);
                CHECK(zip_extract_member(&m, uncomp));
                CHECK(memcmp(uncomp, "aaaa1bbbb2aaaa3bbbb", 19) == 0);
                it = m.next;
        }

        CHECK(it == z.members_end);

        free(uncomp);
}

static const method_t methods[] = {
        ZIP_STORE,
        ZIP_SHRINK,
        ZIP_REDUCE1, ZIP_REDUCE2, ZIP_REDUCE3, ZIP_REDUCE4,
        ZIP_IMPLODE,
        ZIP_DEFLATE
};

void test_zip_write_methods(void)
{
        static const char *const names[] = { "hamlet" };
        static const uint8_t *const data[] = { hamlet };
        static const uint32_t sizes[] = { sizeof(hamlet) };
        time_t mtimes[1];
        size_t max_size, size, mi;
        uint8_t *out;
        zip_t z;
        zipmemb_t m;

        mtimes[0] = magic_time();
        max_size = zip_max_size(1, names, sizes, NULL);
        out = malloc(max_size);

        for (mi = 0; mi < sizeof(methods) / sizeof(methods[0]); mi++) {
                size = zip_write(out, 1, names, data, sizes, mtimes, NULL,
                                 methods[mi], NULL);

                CHECK(zip_read(&z, out, size));
                m = zip_member(&z, z.members_begin);
                CHECK(m.method == methods[mi]);

                check_extract2(&m, (const char*)hamlet, sizeof(hamlet));

                if (methods[mi] == ZIP_DEFLATE) {
                        CHECK(m.made_by_ver == 20);
                } else {
                        CHECK(m.made_by_ver == 10);
                }
        }

        free(out);
}

void test_zip_write_empty_member(void)
{
        static const char *const names[] = { "foo" };
        static const uint8_t *const data[] = { (const uint8_t*)"" };
        static const uint32_t sizes[] = { 0 };
        time_t mtimes[1];
        size_t max_size, size, mi;
        uint8_t *out;
        zip_t z;
        zipmemb_t m;

        mtimes[0] = magic_time();
        max_size = zip_max_size(1, names, sizes, NULL);
        out = malloc(max_size);

        for (mi = 0; mi < sizeof(methods) / sizeof(methods[0]); mi++) {
                size = zip_write(out, 1, names, data, sizes, mtimes, NULL,
                                 methods[mi], NULL);

                CHECK(zip_read(&z, out, size));
                m = zip_member(&z, z.members_begin);
                CHECK(m.method == ZIP_STORE);
                CHECK(m.comp_size == 0);
                CHECK(m.uncomp_size == 0);

                check_extract2(&m, (const char*)"", 0);
        }

        free(out);
}

/* Parse a time string like 2020-02-25 18:55:20 into a time_t value. */
static time_t parse_time(const char *time_string)
{
        struct tm tm = {0};
        int x;

        x = sscanf(time_string, "%4d-%2d-%2d %2d:%2d:%d",
                                &tm.tm_year,
                                &tm.tm_mon,
                                &tm.tm_mday,
                                &tm.tm_hour,
                                &tm.tm_min,
                                &tm.tm_sec);
        assert(x == 6 && "Bad time_string format!");
        (void)x;

        tm.tm_year -= 1900;
        tm.tm_mon  -= 1;

        return mktime(&tm);
}

static void roundtrip_mtime(const char *mtime, const char *expected_mtime)
{
        static const char *const names[] = { "foo" };
        static const uint8_t *const data[] = { (const uint8_t*)"" };
        static const uint32_t sizes[] = { 0 };
        time_t mtimes[1];
        size_t max_size, size;
        uint8_t *out;
        zip_t z;
        zipmemb_t m;

        mtimes[0] = parse_time(mtime);

        max_size = zip_max_size(1, names, sizes, NULL);
        out = malloc(max_size);

        size = zip_write(out, 1, names, data, sizes, mtimes,
                         NULL, ZIP_STORE, NULL);

        zip_read(&z, out, size);
        m = zip_member(&z, z.members_begin);
        CHECK(m.mtime == parse_time(expected_mtime));
        free(out);
}

void test_zip_mtime(void)
{
        roundtrip_mtime("2020-02-25 18:55:20", "2020-02-25 18:55:20");

        /* Only even seconds can be represented; times get rounded down. */
        roundtrip_mtime("2020-02-25 18:55:21", "2020-02-25 18:55:20");

        /* Years are clamped to between 1980 and 2107. */
        roundtrip_mtime("1980-01-02 09:28:32", "1980-01-02 09:28:32");
        roundtrip_mtime("1962-11-03 12:34:56", "1980-11-03 12:34:56");

        if (sizeof(time_t) > sizeof(uint32_t)) {
                /* 32-bit time_t only goes to 2038. */
                roundtrip_mtime("2107-08-09 09:28:32", "2107-08-09 09:28:32");
                roundtrip_mtime("2108-01-02 09:28:32", "2107-01-02 09:28:32");
        }
}
